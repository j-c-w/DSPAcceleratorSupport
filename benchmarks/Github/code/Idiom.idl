Export Constraint ComplexReductionsAndHistograms
(
{icon} is a constant and 
{i2} is bitcast instruction and
{i5} is sext instruction and
{i10} is mul instruction and
{i11} is sext instruction and
{i12} is mul instruction and
{i13} is getElementPtr instruction and
{i14} is bitcast instruction and
{i15} is load instruction and
{i16} is add instruction and
{i17} is sext instruction and
{i18} is mul instruction and
{i19} is getElementPtr instruction and
{i20} is bitcast instruction and
{i21} is load instruction and
{i22} is sext instruction and
{i23} is trunc instruction and
{i24} is sext instruction and
{i25} is sext instruction and

{i28} is trunc instruction and
{i29} is mul instruction and
{i30} is sext instruction and
{i31} is mul instruction and
{i32} is getElementPtr instruction and
{i33} is bitcast instruction and
{i34} is load instruction and
{i35} is add instruction and
{i36} is sext instruction and
{i37} is mul instruction and
{i38} is getElementPtr instruction and
{i39} is bitcast instruction and
{i40} is load instruction and
{i41} is fadd instruction and

{i25} control flow dominates {i28} and

{i10} is first argument of {i12} and
{i12} is second argument of {i13} and
{i13} is first argument of {i15} and
{i10} is first argument of {i16} and
{i16} is first argument of {i18} and
{i18} is second argument of {i19} and
{icon} is first argument of {i19} and

{i29} is first argument of {i31} and
{i31} is second argument of {i32} and
{i0} is first argument of {i32} and
{i32} is first argument of {i34} and
{i29} is first argument of {i35} and
{i35} is first argument of {i37} and
{i37} is second argument of {i38} and
{i0} is first argument of {i38} and

{i2} is not the same as {i14} and
{i2} is not the same as {i20} and
{i14} is not the same as {i20} and
{i2} is not the same as {i33} and
{i14} is not the same as {i33} and
{i20} is not the same as {i33} and
{i2} is not the same as {i39} and
{i14} is not the same as {i39} and
{i20} is not the same as {i39} and
{i33} is not the same as {i39} and

{i5} is not the same as {i11} and
{i5} is not the same as {i17} and
{i11} is not the same as {i17} and
{i5} is not the same as {i22} and
{i11} is not the same as {i22} and
{i17} is not the same as {i22} and
{i5} is not the same as {i24} and
{i11} is not the same as {i24} and
{i17} is not the same as {i24} and
{i22} is not the same as {i24} and
{i5} is not the same as {i25} and
{i11} is not the same as {i25} and
{i17} is not the same as {i25} and
{i22} is not the same as {i25} and
{i24} is not the same as {i25} and
{i5} is not the same as {i30} and
{i11} is not the same as {i30} and
{i17} is not the same as {i30} and
{i22} is not the same as {i30} and
{i24} is not the same as {i30} and
{i25} is not the same as {i30} and
{i5} is not the same as {i36} and
{i11} is not the same as {i36} and
{i17} is not the same as {i36} and
{i22} is not the same as {i36} and
{i24} is not the same as {i36} and
{i25} is not the same as {i36} and
{i30} is not the same as {i36} and

{i10} is not the same as {i12} and
{i10} is not the same as {i18} and
{i12} is not the same as {i18} and

{i13} is not the same as {i19} and
{i13} is not the same as {i32} and
{i19} is not the same as {i32} and
{i13} is not the same as {i38} and
{i19} is not the same as {i38} and
{i32} is not the same as {i38} and

{i15} is not the same as {i21} and
{i15} is not the same as {i29} and
{i21} is not the same as {i29} and
{i15} is not the same as {i31} and
{i21} is not the same as {i31} and
{i29} is not the same as {i31} and
{i15} is not the same as {i34} and
{i21} is not the same as {i34} and
{i29} is not the same as {i34} and
{i31} is not the same as {i34} and
{i15} is not the same as {i40} and
{i21} is not the same as {i40} and
{i29} is not the same as {i40} and
{i31} is not the same as {i40} and
{i34} is not the same as {i40} and

{i10} is not the same as {i29} and
{i10} is not the same as {i31} and
{i29} is not the same as {i31}

)
End

Export Constraint OldVersion
(
  {i125} is load instruction and
  {i131} is load instruction and
  {i145} is load instruction and
  {i151} is load instruction and
  {i158} is fsub instruction and
  {i159} is fsub instruction and
  {i160} is fmul instruction and
  {i161} is fmul instruction and
  {i162} is fsub instruction and
  {i164} is trunc instruction and
  {i165} is mul instruction and
  {i166} is sext instruction and
  {i167} is mul instruction and
  {i168} is getElementPtr instruction and
  {i169} is bitcast instruction and
  {istore} is store instruction and

  {i125} is first argument of {i158} and
  {i131} is second argument of {i158} and
  {i145} is first argument of {i159} and
  {i151} is second argument of {i159} and
  {i158} is first argument of {i160} and
  {i159} is first argument of {ii61} and
  {i160} is first argument of {i162} and
  {i161} is second argument of {i162}
)
End

Constraint VectorRead
( {value} is load instruction and
  {address} is first argument of {value} and
  {base_pointer} is first argument of {address} and
  inherits LocalConst
      with {base_pointer} as {value} and
  {final_index} is second argument of {address} and
  ( ( {final_index} is add instruction and
      inherits ArgumentsPermuted
          with {final_index}   as {dst}
           and {strided_index} as {src1}
           and {offset}        as {src2} and
      inherits LocalConst
          with {offset} as {value} and
      {strided_index} is mul instruction and
      inherits ArgumentsPermuted
          with {strided_index} as {dst}
           and {input_index}   as {src1}
           and {stride}        as {src2} and
      inherits LocalConst
          with {stride} as {value}) or 
    ( {final_index} is mul instruction and
      inherits ArgumentsPermuted
          with {final_index} as {dst}
           and {input_index} as {src1}
           and {stride}      as {src2} and
      inherits LocalConst
          with {stride} as {value} and
      {strided_index} is the same as {final_index} and
      {offset} is unused) or 
    ( {final_index} is the same as {input_index} and
      {strided_index} is the same as {final_index} and
      {offset} is unused and
      {stride} is unused and
      {scope.begin} is instruction)))
End

Constraint ScalarPart
( {kernel.result} reaches phi node
      {old_value} from {loop.end} and
  inherits ScopeValue
      with {loop}      as {scope}
       and {old_value} as {value} and 
  {kernel.result} has data flow to {final_value} and
  {loop.end} strictly control flow
      dominates {final_value} and
  inherits KernelFunction
      with {loop} as {scope} at {kernel} and
  inherits Concat(N1=31,N2=1)
      with {read_values}   as {in1}
       and {old_value}     as {in2}
       and {kernel.inputs} as {out})
End

Constraint HistoPart
( inherits ConditionalReadModifyWrite
      with {loop}              as {scope}
       and {idx_kernel.result} as {address}
       and {val_kernel.result} as {new_value}
                               at {update} and
  inherits KernelFunction
      with {loop}        as {scope}
       and {read_values} as {inputs} at {idx_kernel} and
  inherits KernelFunction
      with {loop} as {scope} at {val_kernel} and
  inherits Concat(N1=31,N2=1)
      with {read_values}       as {in1}
       and {update.old_value}  as {in2}
       and {val_kernel.inputs} as {out})
End

Constraint ConditionalReadModifyWrite
( {store_instr} is store instruction and
  inherits MaxOnceInScope
      with {scope}       as {scope}
       and {store_instr} as {value} at {maxonce} and
  {address} is second argument of {store_instr} and
  {address} is gep instruction and
  {address} is first argument of {old_value} and
  {old_value} is load instruction and
  {new_value} is first argument of {store_instr})
End

Constraint MaxOnceInScope
( inherits ScopeValue and
  {value} has control flow to {value_after} and
  all control flow from {value_after} to
      {value} passes through {scope.end} and
  all control flow from {value_after} to
      {value} passes through {scope.begin})
End

Constraint ScopeValue
( {scope.begin} control flow dominates {value} and
  {scope.end} strictly control flow post dominates {value})
End

Constraint SideEffectFreeCalls
( collect i 20 ( {callsite[i]} is call instruction and
                 inherits ScopeValue
                     with {callsite[i]} as {value}) and
  collect i 20 ( {callsite[i]} is call instruction and
                 inherits ScopeValue
                     with {callsite[i]} as {value} and
                 {function[i]} is first
                     argument of {callsite[i]} and
                 {function[i]} has attribute pure))
End

Constraint For
( inherits Loop and
  {increment} reaches phi node {iterator} from {end} and
  {increment} is first argument of {comparison} and
  {comparison} is icmp instruction and
  {comparison} is first argument of {end} and
  {increment} is add instruction and
  {iterator} is first argument of {increment} and
  {iter_end} is second argument of {comparison} and
  inherits LocalConst
      with {begin}    as {scope.begin}
       and {iter_end} as {value} and
  {iter_begin} reaches phi node
      {iterator} from {precursor} and
  inherits LocalConst
      with {begin}      as {scope.begin}
       and {iter_begin} as {value} and
  {iter_step} is second argument of {increment} and
  inherits LocalConst
      with {begin}     as {scope.begin}
       and {iter_step} as {value})
End

Constraint Loop
( {end} has control flow to {begin} and
  inherits SESE)
End

Constraint SESE
( {precursor} is branch instruction and
  {precursor} has control flow to {begin} and
  {end} is branch instruction and
  {end} has control flow to {successor} and
  {begin} control flow dominates {end} and
  {end} control flow post dominates {begin} and
  {precursor} strictly control flow dominates {begin} and
  {successor} strictly control flow post dominates {end} and
  all control flow from {begin} to {precursor}
         passes through {end} and
  all control flow from {successor} to {end}
         passes through {begin})
End

Constraint LocalConst
( ( {scope.begin} is instruction and
    {value} is preexecution) or
  {value} strictly control flow dominates {scope.begin})
End

Constraint KernelFunction
( collect i  4 ( {entries[i]} has control
                     flow to {scope.begin}) and
  collect i 24 ( inherits LocalConst
                     with {scope} as {scope}
                                  at {outside[i]} and
                 {outside[i].value}
                     is not a numeric constant and
                 {outside[i].value} has data
                     flow to {outside[i].use} and
                 {scope.begin} control flow
                     dominates {outside[i].use}) and
  collect i  8 ( {loop_carried[i].update} reaches
                     phi node {loop_carried[i].value}
                     from {scope.end} and
                 {scope.begin} control flow
                     dominates {loop_carried[i].value}) and
  all flow from {loop_carried[0..8].value} or any origin
      to any of {result} passes through at least one of
      {inputs[0..32],entries[0..4],outside[0..24].value})
End

Constraint ArgumentsPermuted
( ( {src1} is first  argument of {dst} and
    {src2} is second argument of {dst}) or
  ( {src2} is first  argument of {dst} and
    {src1} is second argument of {dst}))
End

Constraint Concat
( if N1=1 then
    {out[0]} is the same as {in1}
  else
    {out[i]} is the same as {in1[i]} for all i=0..N1
  endif and
  if N2=1 then
    {out[N1+0]} is the same as {in2}
  else
    {out[N1+i]} is the same as {in2[i]} for all i=0..N1
  endif and
  if N3=1 then
    {out[N1+N2+0]} is the same as {in3}
  else
    {out[N1+N2+i]} is the same as {in3[i]} for all i=0..N3
  endif)
for N2=0 if not otherwise specified
for N3=0 if not otherwise specified
End

Export
Constraint Distributive
( {value} is add instruction and
  {sum1.value} is first argument of {value} and
  {sum2.value} is second argument of {value} and
  inherits SumChain at {sum1} and
  {product1.value} is the same as {sum1.last_factor} and
  inherits MulChain at {product1} and
  {product1.last_factor} is the same as {product2.last_factor} and
  inherits SumChain at {sum2} and
  {product2.value} is the same as {sum2.last_factor} and
  inherits MulChain at {product2})
End

Constraint SumChain
( {value} is an integer and
  {value} is the same as {results[0]} and
  ( ( {results[i]} is add instruction and
      inherits ArgumentsPermuted with {results[i]}   as {dst}
                                  and {results[i+1]} as {src1}
                                  and {factors[i]}   as {src2} and
      {last_factor} is an integer) or
    ( ( ( {results[i]} is an integer and
          {last_factor} is the same as {factors[i]}) or
        ( {results[i]} is unused and
          {factors[i]} is unused and
          {last_factor} is an integer)) and
      {results[i]} is the same as {factors[i]} and
      {results[i+1]} is unused)) for all i=0..N and
  {factors[N]} is unused)
for N=4 if not otherwise specified
End

Constraint MulChain
( {value} is an integer and
  {value} is the same as {results[0]} and
  ( ( {results[i]} is mul instruction and
      inherits ArgumentsPermuted with {results[i]}   as {dst}
                                  and {results[i+1]} as {src1}
                                  and {factors[i]}   as {src2} and
      {last_factor} is an integer) or
    ( ( ( {results[i]} is an integer and
          {last_factor} is the same as {factors[i]}) or
        ( {results[i]} is unused and
          {factors[i]} is unused and
          {last_factor} is an integer)) and
      {results[i]} is the same as {factors[i]} and
      {results[i+1]} is unused)) for all i=0..N and
  {factors[N]} is unused)
for N=4 if not otherwise specified
End

Export
Constraint HoistSelect
( {select} is select instruction and
  {input1} is second argument of {select} and
  {base} is first argument of {input1} and
  {input2} is third argument of {select} and
  {base} is first argument of {input2} and
  {input1} is gep instruction and
  {input2} is gep instruction)
End

Export
Constraint ForWithIteratorTest
( inherits Loop and
  {comparison} has data flow to {end} and
  {comparison} is icmp instruction and
  {iterator} has data flow to {comparison} and
  {increment} reaches phi node {iterator} from {end} and
  {increment} has data flow to {iterator} and
  {increment} is add instruction and
  {iterator} has data flow to {increment} and
  {iter_end} has data flow to {comparison} and
  inherits LocalConst with {iter_end} as {value}
                       and {begin}    as {scope.begin} and
  {iter_begin} has data flow to {iterator} and
  inherits LocalConst with {iter_begin} as {value}
                       and {begin}      as {scope.begin} and
  {iter_step} has data flow to {increment} and
  inherits LocalConst with {iter_step} as {value}
                       and {begin}     as {scope.begin})
End
